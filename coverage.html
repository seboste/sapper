
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adapters: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/seboste/sapper/adapters/filesystem-brick-db.go (87.5%)</option>
				
				<option value="file1">github.com/seboste/sapper/adapters/filesystem-service-persistence.go (0.0%)</option>
				
				<option value="file2">github.com/seboste/sapper/core/brick-api.go (25.0%)</option>
				
				<option value="file3">github.com/seboste/sapper/core/remote-api.go (0.0%)</option>
				
				<option value="file4">github.com/seboste/sapper/core/section.go (97.2%)</option>
				
				<option value="file5">github.com/seboste/sapper/core/service-api.go (73.7%)</option>
				
				<option value="file6">github.com/seboste/sapper/ports/brick-db.go (45.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package adapters

import (
        "errors"
        "io/ioutil"
        "os"
        "path/filepath"

        "github.com/seboste/sapper/ports"
        "gopkg.in/yaml.v3"
)

var BrickNotFound = errors.New("brick not found")

func makeBrick(path string) (ports.Brick, error) <span class="cov8" title="1">{
        b := ports.Brick{}

        yamlFile, err := ioutil.ReadFile(filepath.Join(path, "manifest.yaml"))
        if err != nil </span><span class="cov0" title="0">{
                return ports.Brick(b), err
        }</span>
        <span class="cov8" title="1">err = yaml.Unmarshal(yamlFile, &amp;b)
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov8" title="1">b.BasePath = filepath.Join(path, "")
        err = filepath.Walk(path,
                func(p string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">_, file := filepath.Split(p)

                        if file == "manifest.yaml" </span><span class="cov8" title="1">{
                                return nil //skip manifest.yaml
                        }</span>

                        <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                                //skip directories
                                return nil
                        }</span>

                        <span class="cov8" title="1">relPath, _ := filepath.Rel(path, p)
                        b.Files = append(b.Files, relPath)
                        return nil</span>
                })

        <span class="cov8" title="1">return b, nil</span>
}

type FilesystemBrickDB struct {
        bricks []ports.Brick
}

func (db *FilesystemBrickDB) Init(basePath string) error <span class="cov8" title="1">{
        err := filepath.Walk(basePath,
                func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">dir, file := filepath.Split(path)

                        if file == "manifest.yaml" </span><span class="cov8" title="1">{
                                brick, err := makeBrick(dir)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">db.bricks = append(db.bricks, brick)</span>
                        }

                        <span class="cov8" title="1">return nil</span>
                })
        <span class="cov8" title="1">return err</span>
}

func (db *FilesystemBrickDB) Bricks(kind ports.BrickKind) []ports.Brick <span class="cov8" title="1">{
        filteredBricks := []ports.Brick{}
        for _, b := range db.bricks </span><span class="cov8" title="1">{
                if b.Kind == kind </span><span class="cov8" title="1">{
                        filteredBricks = append(filteredBricks, b)
                }</span>
        }
        <span class="cov8" title="1">return filteredBricks</span>
}

func (db *FilesystemBrickDB) Brick(id string) (ports.Brick, error) <span class="cov8" title="1">{
        for _, b := range db.bricks </span><span class="cov8" title="1">{
                if b.Id == id </span><span class="cov8" title="1">{
                        return b, nil
                }</span>
        }
        <span class="cov8" title="1">return ports.Brick{}, BrickNotFound</span>
}

var _ ports.BrickDB = &amp;FilesystemBrickDB{}
</pre>
		
		<pre class="file" id="file1" style="display: none">package adapters

import (
        "io/ioutil"
        "path/filepath"

        "github.com/seboste/sapper/ports"
        "gopkg.in/yaml.v3"
)

type FileSystemServicePersistence struct {
}

func (fsp FileSystemServicePersistence) Load(path string) (ports.Service, error) <span class="cov0" title="0">{
        s := ports.Service{Path: path}

        sapperFilePath := filepath.Join(s.Path, "sapperfile.yaml")

        yamlData, err := ioutil.ReadFile(sapperFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>

        <span class="cov0" title="0">if err := yaml.Unmarshal(yamlData, &amp;s); err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}

func (fsp FileSystemServicePersistence) Save(s ports.Service) error <span class="cov0" title="0">{

        yamlData, err := yaml.Marshal(s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sapperFilePath := filepath.Join(s.Path, "sapperfile.yaml")
        err = ioutil.WriteFile(sapperFilePath, yamlData, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "fmt"
        "strings"

        "github.com/seboste/sapper/ports"
)

type BrickApi struct {
        Db                 ports.BrickDB
        ServicePersistence ports.ServicePersistence
}

func removeBricks(bricks []ports.Brick, brickIdsToRemove []ports.BrickDependency) []ports.Brick <span class="cov8" title="1">{
        brickIdsToRemoveMap := make(map[string]bool)
        for _, b := range brickIdsToRemove </span><span class="cov8" title="1">{
                brickIdsToRemoveMap[b.Id] = true
        }</span>

        <span class="cov8" title="1">filteredBricks := []ports.Brick{}
        for _, b := range bricks </span><span class="cov8" title="1">{
                if brickIdsToRemoveMap[b.Id] == false </span><span class="cov8" title="1">{
                        filteredBricks = append(filteredBricks, b)
                }</span>
        }
        <span class="cov8" title="1">return filteredBricks</span>
}

func (b BrickApi) Add(servicePath string, brickId string, parameterResolver ports.ParameterResolver) error <span class="cov0" title="0">{

        bricks, err := GetBricksRecursive(brickId, b.Db, map[string]bool{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">service, err := b.ServicePersistence.Load(servicePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bricks = removeBricks(bricks, service.BrickIds) //remove all bricks that are already there

        if len(bricks) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("brick %s has already been added.", brickId)
        }</span>

        <span class="cov0" title="0">parameters, err := ResolveParameterSlice(bricks, parameterResolver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, brick := range bricks </span><span class="cov0" title="0">{
                if err := AddSingleBrick(&amp;service, brick, parameters); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := b.ServicePersistence.Save(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b BrickApi) List() []ports.Brick <span class="cov0" title="0">{
        return b.Db.Bricks(ports.Extension)
}</span>

func (b BrickApi) Search(term string) []ports.Brick <span class="cov0" title="0">{
        filteredBricks := []ports.Brick{}
        for _, brick := range b.Db.Bricks(ports.Extension) </span><span class="cov0" title="0">{
                if strings.Contains(brick.Id, term) || strings.Contains(brick.Description, term) </span><span class="cov0" title="0">{
                        filteredBricks = append(filteredBricks, brick)
                }</span>
        }
        <span class="cov0" title="0">return filteredBricks</span>
}

var _ ports.BrickApi = BrickApi{}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "fmt"

        "github.com/seboste/sapper/ports"
)

type RemoteApi struct {
}

func (r RemoteApi) Add() <span class="cov0" title="0">{
        fmt.Println("add")
}</span>

func (r RemoteApi) List() <span class="cov0" title="0">{
        fmt.Println("list")
}</span>

var _ ports.RemoteApi = RemoteApi{}
</pre>
		
		<pre class="file" id="file4" style="display: none">package core

import (
        "bufio"
        "fmt"
        "regexp"
        "strings"
)

type section struct {
        name      string
        verb      string
        lineBegin int //first line number after the begin tag
        lineEnd   int //the line number of the end tag
        content   string
}

type tag struct {
        name  string
        begin bool
        verb  string
}

func readTag(line string) *tag <span class="cov8" title="1">{
        tagExp := regexp.MustCompile(`&lt;&lt;&lt;SAPPER\s*SECTION\s*(BEGIN|END)(\s*(APPEND|REPLACE|PREPEND))?\s*(.*?)&gt;&gt;&gt;`)

        matches := tagExp.FindStringSubmatch(line)
        if len(matches) != 5 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">t := tag{name: matches[4], verb: matches[3]}

        if matches[1] == "BEGIN" </span><span class="cov8" title="1">{
                t.begin = true
        }</span>

        <span class="cov8" title="1">return &amp;t</span>
}

func toMap(sections []section) map[string]section <span class="cov8" title="1">{
        sectionMap := map[string]section{}
        for _, s := range sections </span><span class="cov8" title="1">{
                sectionMap[s.name] = s
        }</span>
        <span class="cov8" title="1">return sectionMap</span>
}

func readSections(data string) ([]section, error) <span class="cov8" title="1">{
        sections := []section{}
        scanner := bufio.NewScanner(strings.NewReader(data))
        var currentSection *section = nil
        lineCount := 0
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                if tag := readTag(line); tag != nil </span><span class="cov8" title="1">{
                        if tag.begin == true </span><span class="cov8" title="1">{
                                if currentSection != nil </span><span class="cov8" title="1">{
                                        return sections, fmt.Errorf("found nested begin tag %s in existing section %s in line %d", tag.name, currentSection.name, lineCount)
                                }</span>
                                <span class="cov8" title="1">currentSection = &amp;section{
                                        name:      tag.name,
                                        verb:      tag.verb,
                                        lineBegin: lineCount + 1,
                                }</span>
                        } else<span class="cov8" title="1"> { //tag.begin == false, i.e. end of a section
                                if currentSection == nil </span><span class="cov8" title="1">{
                                        return sections, fmt.Errorf("found end tag %s without preceeding begin tag in line %d", tag.name, lineCount)
                                }</span>
                                <span class="cov8" title="1">if tag.name != currentSection.name </span><span class="cov0" title="0">{
                                        return sections, fmt.Errorf("found end tag %s does not match the begin tag %s in line %d", tag.name, currentSection.name, lineCount)
                                }</span>
                                <span class="cov8" title="1">currentSection.lineEnd = lineCount
                                sections = append(sections, *currentSection)
                                currentSection = nil</span>
                        }
                } else<span class="cov8" title="1"> {
                        if currentSection != nil </span><span class="cov8" title="1">{
                                if currentSection.content == "" </span><span class="cov8" title="1">{
                                        currentSection.content = line
                                }</span> else<span class="cov8" title="1"> {
                                        currentSection.content = fmt.Sprintln(currentSection.content) + line
                                }</span>
                        }
                }
                <span class="cov8" title="1">lineCount = lineCount + 1</span>
        }
        <span class="cov8" title="1">return sections, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package core

import (
        "bufio"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/seboste/sapper/ports"
)

type ServiceApi struct {
        Db                 ports.BrickDB
        ServicePersistence ports.ServicePersistence
        ParameterResolver  ports.ParameterResolver
}

func ResolveParameters(bp []ports.BrickParameters, pr ports.ParameterResolver) (map[string]string, error) <span class="cov8" title="1">{
        parameters := make(map[string]string)
        for _, p := range bp </span><span class="cov8" title="1">{
                value := pr.Resolve(p.Name)
                if value == "" </span><span class="cov8" title="1">{
                        value = p.Default
                }</span>
                <span class="cov8" title="1">if value == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("unable to resolve value for parameter %s", p.Name)
                }</span>
                <span class="cov8" title="1">parameters[p.Name] = value</span>
        }
        <span class="cov8" title="1">return parameters, nil</span>
}

func ResolveParameterSlice(bricks []ports.Brick, pr ports.ParameterResolver) (map[string]string, error) <span class="cov8" title="1">{
        combinedParameters := map[string]string{}
        for _, brick := range bricks </span><span class="cov8" title="1">{
                p, err := ResolveParameters(brick.Parameters, pr)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for k, v := range p </span><span class="cov8" title="1">{
                        combinedParameters[k] = v
                }</span>
        }
        <span class="cov8" title="1">return combinedParameters, nil</span>
}

func AddSingleBrick(s *ports.Service, b ports.Brick, parameters map[string]string) error <span class="cov8" title="1">{
        for _, f := range b.Files </span><span class="cov8" title="1">{
                inputFilePath := filepath.Join(b.BasePath, f)
                if _, err := os.Stat(inputFilePath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">outputFilePath := filepath.Join(s.Path, f)
                outputDir, _ := filepath.Split(outputFilePath)
                if err := os.MkdirAll(outputDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">content, err := ioutil.ReadFile(inputFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">contentStr := string(content)

                contentStr = replaceParameters(contentStr, parameters)

                if _, err := os.Stat(outputFilePath); errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{ //file does not exit =&gt; just write out the content
                        err = ioutil.WriteFile(outputFilePath, []byte(contentStr), 0644)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> { //file exists =&gt; merge Sections
                        inputSectionSlice, err := readSections(contentStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">inputSections := toMap(inputSectionSlice)

                        outputContent, err := ioutil.ReadFile(outputFilePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">outputContentStr := string(outputContent)

                        mergedOutputContentStr, err := mergeSections(outputContentStr, inputSections)

                        err = ioutil.WriteFile(outputFilePath, []byte(mergedOutputContentStr), 0644)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.BrickIds = append(s.BrickIds, ports.BrickDependency{b.Id, b.Version})

        return nil</span>
}

func mergeSection(base section, incoming section) (string, error) <span class="cov8" title="1">{

        if base.name != incoming.name </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Unable to merge section %s with section %s. Names must match.", base.name, incoming.name)
        }</span>

        <span class="cov8" title="1">if base.verb != "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Unable to merge section %s. Base operation must not be defined.", base.name)
        }</span>

        <span class="cov8" title="1">if incoming.verb == "REPLACE" </span><span class="cov8" title="1">{
                return incoming.content, nil
        }</span> else<span class="cov8" title="1"> if incoming.verb == "PREPEND" </span><span class="cov8" title="1">{
                var content string
                content = content + incoming.content
                if base.content != "" &amp;&amp; incoming.content != "" </span><span class="cov8" title="1">{
                        content = content + fmt.Sprintln("")
                }</span>
                <span class="cov8" title="1">content = content + base.content
                return content, nil</span>
        } else<span class="cov8" title="1"> if incoming.verb == "APPEND" </span><span class="cov8" title="1">{
                var content string
                content = content + base.content
                if base.content != "" &amp;&amp; incoming.content != "" </span><span class="cov8" title="1">{
                        content = content + fmt.Sprintln("")
                }</span>
                <span class="cov8" title="1">content = content + incoming.content
                return content, nil</span>
        } else<span class="cov8" title="1"> {
                return "", fmt.Errorf("Unable to merge section %s. Invalid incoming operation %s.", base.name, incoming.verb)
        }</span>
}

func mergeSections(content string, inputSections map[string]section) (string, error) <span class="cov8" title="1">{
        outputSections, err := readSections(content)
        if err != nil </span><span class="cov0" title="0">{
                return content, err
        }</span>

        <span class="cov8" title="1">scanner := bufio.NewScanner(strings.NewReader(content))

        outputContent := ""
        lineNumber := 0
        for _, s := range outputSections </span><span class="cov8" title="1">{
                //advance to next section
                for lineNumber &lt; s.lineBegin &amp;&amp; scanner.Scan() </span><span class="cov8" title="1">{
                        outputContent = outputContent + fmt.Sprintln(scanner.Text())
                        lineNumber = lineNumber + 1
                }</span>

                <span class="cov8" title="1">if incomingSection, ok := inputSections[s.name]; ok </span><span class="cov8" title="1">{
                        mergedSectionContent, err := mergeSection(s, incomingSection)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if mergedSectionContent != "" </span><span class="cov8" title="1">{
                                outputContent = outputContent + fmt.Sprintln(mergedSectionContent)
                        }</span>
                } else<span class="cov8" title="1"> { // no incoming section =&gt; just use base content
                        outputContent = outputContent + s.content
                }</span>
                <span class="cov8" title="1">for lineNumber &lt; s.lineEnd &amp;&amp; scanner.Scan() </span><span class="cov8" title="1">{ //skip section content
                        lineNumber = lineNumber + 1
                }</span>

                //take care of end tag
                <span class="cov8" title="1">scanner.Scan()
                outputContent = outputContent + fmt.Sprintln(scanner.Text())
                lineNumber = lineNumber + 1</span>
        }

        //copy incoming content after last section
        <span class="cov8" title="1">for scanner.Scan() </span><span class="cov8" title="1">{
                outputContent = outputContent + fmt.Sprintln(scanner.Text())
                lineNumber = lineNumber + 1
        }</span>

        <span class="cov8" title="1">return outputContent, nil</span>
}

func replaceParameters(content string, parameters map[string]string) string <span class="cov8" title="1">{
        for name, value := range parameters </span><span class="cov8" title="1">{
                pattern := "&lt;&lt;&lt;" + name + "&gt;&gt;&gt;"
                content = strings.ReplaceAll(content, pattern, value)
        }</span>
        <span class="cov8" title="1">return content</span>
}

func GetBricksRecursive(brickId string, db ports.BrickDB, parentBrickIds map[string]bool) ([]ports.Brick, error) <span class="cov8" title="1">{

        brickIds := make(map[string]bool)
        for k, v := range parentBrickIds </span><span class="cov8" title="1">{
                brickIds[k] = v
        }</span>

        <span class="cov8" title="1">bricks := []ports.Brick{}

        if brickIds[brickId] == true </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cyclic brick dependency")
        }</span>

        <span class="cov8" title="1">brick, err := db.Brick(brickId)
        if err != nil </span><span class="cov0" title="0">{
                return bricks, fmt.Errorf("invalid brick %s", brickId)
        }</span>

        <span class="cov8" title="1">bricks = append(bricks, brick)
        brickIds[brick.Id] = true

        //deep copy to identify cyclic dependencies
        baselineBrickIds := make(map[string]bool)
        for k, v := range brickIds </span><span class="cov8" title="1">{
                baselineBrickIds[k] = v
        }</span>

        <span class="cov8" title="1">for _, dependencyId := range brick.Dependencies </span><span class="cov8" title="1">{
                dependencies, err := GetBricksRecursive(dependencyId, db, baselineBrickIds)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">for _, dependency := range dependencies </span><span class="cov8" title="1">{
                        if brickIds[dependency.Id] == false </span><span class="cov8" title="1">{
                                bricks = append(bricks, dependency)
                                brickIds[dependency.Id] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return bricks, nil</span>
}

func (s ServiceApi) Add(templateName string, parentDir string, parameterResolver ports.ParameterResolver) error <span class="cov0" title="0">{

        bricks, err := GetBricksRecursive(templateName, s.Db, map[string]bool{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">parameters, err := ResolveParameterSlice(bricks, parameterResolver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(bricks) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid template %s", templateName)
        }</span>

        <span class="cov0" title="0">serviceName := parameters["NAME"]
        if serviceName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid service name %s", serviceName)
        }</span>
        <span class="cov0" title="0">outputBasePath := filepath.Join(parentDir, serviceName)
        if err := os.MkdirAll(outputBasePath, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">service := ports.Service{Id: serviceName, Path: outputBasePath}

        for _, brick := range bricks </span><span class="cov0" title="0">{
                if err := AddSingleBrick(&amp;service, brick, parameters); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := s.ServicePersistence.Save(service); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s ServiceApi) Update() <span class="cov0" title="0">{
        fmt.Println("update")
}</span>

func (s ServiceApi) Build(path string) error <span class="cov0" title="0">{
        cmd := exec.Command("make", "build", "-B")
        cmd.Dir = path
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err := cmd.Run()
        return err
}</span>

func (s ServiceApi) Test() <span class="cov0" title="0">{
        fmt.Println("test")
}</span>

func (s ServiceApi) Deploy() <span class="cov0" title="0">{
        fmt.Println("deploy")
}</span>

var _ ports.ServiceApi = ServiceApi{}
</pre>
		
		<pre class="file" id="file6" style="display: none">package ports

import (
        "fmt"
        "strings"

        "gopkg.in/yaml.v3"
)

type BrickParameters struct {
        Name    string
        Default string
}

type BrickKind int

const (
        Template BrickKind = iota
        Extension
)

type Brick struct {
        Id           string
        Description  string
        Version      string
        Kind         BrickKind
        Parameters   []BrickParameters
        Dependencies []string
        BasePath     string
        Files        []string
}

type BrickDB interface {
        Init(Path string) error
        Bricks(kind BrickKind) []Brick
        Brick(id string) (Brick, error)
}

var (
        brickKindMap = map[string]BrickKind{
                "template":  BrickKind(Template),
                "extension": BrickKind(Extension),
        }
)

func ParseBrickKind(str string) (BrickKind, bool) <span class="cov8" title="1">{
        c, ok := brickKindMap[strings.ToLower(str)]
        return c, ok
}</span>

func (bk BrickKind) String() string <span class="cov8" title="1">{
        switch BrickKind(bk) </span>{
        case Template:<span class="cov8" title="1">
                return "template"</span>
        case Extension:<span class="cov8" title="1">
                return "extension"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%d", int(bk))</span>
        }
}

func (bk *BrickKind) UnmarshalYAML(value *yaml.Node) error <span class="cov0" title="0">{
        ok := false
        *bk, ok = ParseBrickKind(value.Value)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid brick kind %s", value.Value)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
